# 序章

在正式开始之前，我们假设读者已经熟练掌握了 C++ 基础语法、计算机网络、操作系统以及Socket编程等相关知识；如果您对上述内容尚不熟悉，请先行补充学习——至少要知道他们的原理和工作方式，不然你将很难理解代码。本文并非一份完整的技术知识图谱，而是按照项目开发流程，结合实际案例，逐步介绍涉及到的概念与用法。

如果您希望系统地深入掌握 Linux 服务端开发，推荐阅读以下经典著作之一：

- 陈硕：《Linux 多线程服务端编程——使用 muduo C++ 网络库》
- 游双：《Linux 高性能服务器编程》
- 张元龙：《C++ 服务器开发精髓》

阅读上述书籍并结合本项目实践，您将能有条不紊地将零散的知识点串联起来，逐步构建完整的开发能力。

# 网络模型搭建

## 一、基础知识

### 1、网络通信流程

我们写网络服务程序，首先要知道一个服务程序，他的工作流程是什么。在一次网络通信中，服务端首先会调用操作系统的**`socket`**函数创建一个socket，在之后这个socket我们称为**侦听socket**，然后调用**`bind`**函数绑定IP和端口号，最后调用**`listen`**函数开始侦听；而后每当一个客户端尝试连接服务端，服务端会调用**`accept`**函数接受连接，同时产生一个新的socket，在之后这个socket我们称为**客户端socket**，之后就可以基于这个客户端socket，调用recv和send方法收发数据，最后则调用close关闭侦听socket

### 2、Socket事件

Socket事件细分可以分很多种，我们这里只关心**读事件**和**写事件**，通常读写事件会在以下情况时触发

**读事件:**

- 接收到数据时
- 侦听socket上有连接请求时
- 对端半关闭（FIN）
- socket上有异常事件未处理时

**写事件:**

- 需要发送数据时
- socket写操作被关闭（调用了close或者shutdown函数)
- socket使用非阻塞连接，并且连接成功或者失败时

在Linux使用epoll的 边缘和水平模式时会有不同的效果，这个我们先按下不表。

### 3、事件处理模式

目前主流的事件处理模式主要有两种，Reactor模式和Proactor模式。他们其实是基于两种不同的I/O模型进行构建的，Reactor模式是基于同步I/O模型，而Proactor模式是基于异步I/O模型。而本项目就基于Reactor模式进行开发。

Reactor模式的事件处理的流程图如下图。

![Reactor模式](.\image\Reactor模式.png)

从流程图来看，reactor模式就是接受外部请求，然后通过事件分发器发送给对应的处理程序处理。所以一个Reactor模式的网络结构通常包括以下模块：

- 资源请求事件（Resource Request）
- 多路复用器（IODemultiPlexer）
- 事件分发器（EventDispatcher）
- 事件处理器（EventHandler）

### 4、One Thread One Loop

基于Reactor模式，我们引出**`one thread one loop`**思想。即一个线程对应一个循环，这里的线程指的是网络线程，而循环指的是事件处理循环，也就是说在网络程序中，所有的线程都只做一件事，正如我们上面的流程图中所展示的那样，我们这个线程的循环中需要做的就是：

1. 利用I/O复用模型，分离出读写事件
2. 处理读写事件
3. 做一些其他事情（定时器事件、自定义唤醒事件）

### 5、I/O复用技术

I/O复用技术能够使得程序能够同时监听多个文件描述符，这对提高服务程序的性能至关重要，Linux上实现的I/O复用技术的系统调用主要有select、poll和epoll，Windows上也有WSASelect、WSASyncSelect、WSAPoll和iocpdeng 。之后我们在代码会实现所有的I/O复用技术的封装，这里不对I/O复用做过多的赘述，你需要知道是，他的作用就是同时监听文件描述符，并且识别是读事件还是些事件。

### 6、网络分层

正如计算机网络中的分层模型一样，我们在进行网络开发时，也会将网络程序进行分层。在很多的网络通信库当中，一般是将程序分为四层：Session层、Connection层、Channel层和Socket层

![网络分层](.\image\网络分层.png)

Session层的作用是记录各种业务状态和处理业务逻辑，处理完毕之后将数据发给Connection层进行收发，Connection层一般也会管理连接状态、数据收发缓冲区信息、数据流量记录状态、本端和对端地址和端口号信息等重要状态，而Channel层则是实际数据收发的地方，一般由他管理着Socket的生命周期，而Socket层则只是对底层Socket相关的系统API做一层封装。

## 二、程序设计与实现

### 1、总体设计

有了以上的基础之后，我们基本可以设计出网络模块的核心成员类。

首先，由于我们使用Reactor模型，因此首先抽象出**`EventDispatcher`**类。那么具体又是谁在做事件分发这个事情呢？根据我们之前所说的网络通信流程，其实有两个地方，当服务端启动会产生一个侦听socket，客户端发起连接时，就会产生事件，第二个调用recv和send方法时，也会产生读写事件；因此我们可以设计两个类，一个叫做**`Listener`**或者**`Acceptor`**，而另一个就是我们的**`TCPConnection`**，并且我们设置一个**`TCPServer`**类来管理**`Acceptor`**和**`TCPConnection`**。然后我们在抽象出I/O复用模型，**`IOMultiplex`**类，并且之后分别是实现**`Select`**、**`Poll`**、**`Epoll`**三个I/O复用模型。因为我们基于one thread one loop思想，因此抽象出一个**`EventLoop`**类处理时间循环的逻辑，然后使用它是创建线程。为了方便管理，我们将添加线程池**`ThreadPool`**用于获取线程和用于提高性能，最后我再添加一个**`ByteBuffer`**类用作服务端的接收和发送缓冲区。

### 2、Buffer

### 3、IOMultiplex

### 4、EventDispatcher

### 5、EventLoop

### 6、ThreadPool

### 7、TCPServer

### 8、TCPClient
