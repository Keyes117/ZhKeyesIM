# 日志回调设计思路与实现方案

## 一、核心设计理念

### 1.1 依赖倒置原则（DIP）

传统方式（违反 DIP）：

高层模块（GateServer）

  ↓ 依赖

中层模块（net、util）

  ↓ 依赖

底层模块（Log）

- 问题：中层模块（库）硬编码依赖具体的日志实现

- 结果：库无法独立使用，必须连带日志系统

日志回调方式（遵循 DIP）：

高层模块（GateServer）

  ↓ 实现

日志接口（抽象层）

  ↑ 依赖

中层模块（net、util）

- 中层模块只依赖抽象接口（回调函数类型）

- 高层模块提供具体实现（日志回调）

- 依赖方向反转：都依赖抽象

### 1.2 控制反转（IoC）

关键思想：库不主动调用具体日志，而是"请求"上层提供日志能力

- 传统：LOG_ERROR("错误") → 直接调用 Logger

- 回调：logCallback(Error, "错误") → 调用上层注入的函数

------

## 二、架构设计

### 2.1 三层架构

┌─────────────────────────────────────────┐

│    应用层（GateServer/Client）    │

│ - 初始化具体日志实现（Logger）      │

│ - 注册日志回调函数            │

│ - 桥接：回调 → Logger          │

└─────────────────────────────────────────┘

​         ↓ 注入回调

┌─────────────────────────────────────────┐

│     抽象层（LogCallback）      │

│ - 定义回调函数类型            │

│ - 提供注册/调用接口           │

│ - 不包含具体实现            │

└─────────────────────────────────────────┘

​         ↑ 使用抽象

┌─────────────────────────────────────────┐

│    库层（net、util）         │

│ - 通过抽象层记录日志           │

│ - 不依赖具体日志库            │

└─────────────────────────────────────────┘

### 2.2 职责划分

#### 抽象层（LogCallback）

- 位置：放在 util 库中（最基础的库）

- 职责：

- 定义日志回调函数类型签名

- 提供全局回调注册机制

- 提供统一的日志调用入口

- 不包含具体的日志格式化、输出逻辑

#### 库层（net、util）

- 职责：

- 在需要日志的地方调用抽象层接口

- 不关心日志如何实现

- 如果没有回调，优雅降级（静默或输出到 stderr）

#### 应用层（GateServer）

- 职责：

- 初始化具体日志系统（Logger）

- 创建并注册回调函数（适配器模式）

- 决定日志级别、格式、输出位置

------

## 三、实现方案要点

### 3.1 回调函数类型设计

需要传递的信息：

- 日志级别（Debug/Info/Warn/Error）

- 日志消息（格式化后的字符串）

- 可选：时间戳、线程ID、源文件位置

类型签名选择：

- 方案A：void callback(LogLevel level, const std::string& message)

- 简单，库层负责格式化

- 上层只需转发

- 方案B：void callback(const LogInfo& info)

- 传递结构体，包含更多元数据

- 上层有更大控制权（可以自定义格式化）

推荐方案A：保持简单，库层已经格式化好消息

### 3.2 回调存储机制

静态全局存储：

- 在抽象层使用 static 变量存储回调函数

- 单例模式或直接静态成员

线程安全考虑：

- 注册阶段：通常在主线程初始化时注册，可以不加锁

- 调用阶段：多线程调用日志，但只读回调指针，天然线程安全

- 如果支持动态更换回调，需要加锁或使用 std::atomic

### 3.3 性能优化

零开销原则（如果不启用日志）：

inline void log(LogLevel *level*, const char* *fmt*, ...)

{

  if (!s_logCallback) *// 快速返回*

​    return;

  

  *// 只有有回调才进行格式化*

  *// ...*

}

编译期优化：

- 使用内联函数避免函数调用开销

- 编译器可以优化掉未使用的日志调用

### 3.4 向后兼容性

提供宏封装：

- 库代码不直接调用 LogManager::log()

- 使用宏 UTIL_LOG_ERROR(fmt, ...)

- 未来可以替换实现而不改库代码

------

## 四、调用流程详解

### 4.1 初始化流程

1. main() 启动

  ↓

2. 初始化具体日志系统

  Logger::instance().setLogFile("app.log")

  ↓

3. 创建适配器（lambda/函数）

  auto adapter = [](level, msg) { Logger::log(level, msg); }

  ↓

4. 注册到抽象层

  LogManager::setLogCallback(adapter)

  ↓

5. 启动业务（net、util 库可以记录日志了）

### 4.2 运行时流程

库层发起日志：

JsonUtil::parseSafe()

  ↓ 解析失败

UTIL_LOG_ERROR("parse error: %s", e.what())

  ↓ 宏展开

LogManager::log(Error, "parse error: %s", e.what())

  ↓ 格式化

vsnprintf(buffer, fmt, args) → "parse error: invalid token"

  ↓ 检查回调

if (s_logCallback)

  ↓ 调用回调

s_logCallback(Error, "parse error: invalid token")

  ↓ 跳转到应用层

lambda 函数

  ↓ 转发到具体实现

Logger::instance().log(ERR, "parse error: invalid token")

  ↓

Logger 写入文件/控制台

------

## 五、设计优势分析

### 5.1 解耦优势

库的独立性：

- net、util 可以编译为独立库发布

- 其他项目可以使用自己的日志系统（spdlog、glog、log4cpp）

- 甚至可以不启用日志（嵌入式、高性能场景）

测试友好：

- 单元测试时可以注册 mock 回调

- 验证库是否在正确时机记录了日志

- 不需要真实的日志系统

### 5.2 灵活性优势

运行时可配置：

- 可以动态切换日志输出（文件 → 网络 → 禁用）

- 不同模块可以使用不同的回调

- 支持日志过滤、重定向等高级功能

多种输出方式：

- 控制台（开发调试）

- 文件（生产环境）

- 网络（日志收集系统）

- 数据库（审计日志）

- GUI窗口（桌面应用）

### 5.3 性能优势

按需开销：

- 如果不注册回调，日志调用几乎零开销（一次指针判断）

- 避免强制初始化日志系统带来的开销

- 可以针对不同场景优化（release 关闭 Debug 日志）

------

## 六、实现方案的组成部分

### 6.1 抽象层需要提供

1. 回调类型定义

- 日志级别枚举

- 回调函数类型（std::function）

1. 管理器类/命名空间

- 注册回调的接口

- 调用回调的内部函数

- 存储回调的静态成员

1. 便捷宏

- UTIL_LOG_DEBUG/INFO/WARN/ERROR

- 封装格式化和调用逻辑

### 6.2 库层需要修改

1. 替换日志调用

- LOG_ERROR(...) → UTIL_LOG_ERROR(...)

- 移除对 Logger.h 的依赖

1. 构建脚本修改

- 移除对 Log 库的链接依赖

- 移除 Log 头文件路径

### 6.3 应用层需要添加

1. 初始化代码

- 启动具体日志系统

- 创建适配器函数

- 注册回调

1. 级别映射

- 抽象层的 LogLevel 枚举

- 具体日志系统的级别枚举

- 需要映射转换

------

## 七、与其他方案对比

### 7.1 vs 直接依赖日志库

| 方面       | 日志回调       | 直接依赖           |
| :--------- | :------------- | :----------------- |
| 耦合度     | 低，只依赖抽象 | 高，硬编码依赖     |
| 可复用性   | 强，独立发布   | 弱，必须连带日志库 |
| 灵活性     | 可换日志实现   | 固定实现           |
| 性能       | 可选开销       | 强制初始化         |
| 实现复杂度 | 需要适配器     | 直接调用           |

### 7.2 vs 宏条件编译

| 方面       | 日志回调        | 条件编译     |
| :--------- | :-------------- | :----------- |
| 灵活性     | 运行时决定      | 编译时决定   |
| 易用性     | 无需重新编译    | 需要重新编译 |
| 性能       | 相当            | 相当         |
| 二进制兼容 | 同一个 .so/.dll | 需要多个版本 |

### 7.3 vs 策略模式

日志回调本质上是策略模式的轻量实现：

- 回调函数 = 策略接口

- Lambda/函数指针 = 具体策略

- 不需要完整的类继承体系，更轻量

------

## 八、注意事项

### 8.1 生命周期管理

回调函数的生命周期：

- 确保注册的回调在整个程序生命周期有效

- Lambda 捕获的变量要注意生命周期

- 使用单例 Logger 通常没问题

### 8.2 异常安全

回调内部抛异常：

- 库层调用回调时应捕获异常

- 避免用户提供的回调崩溃整个程序

- 或者明确约定回调不允许抛异常

### 8.3 递归日志

避免无限递归：

应用层回调

 ↓ 调用 Logger::log()

 ↓ Logger 内部使用了 net 库

 ↓ net 库调用 NET_LOG_XXX()

 ↓ 触发回调

 ↓ 调用 Logger::log()

 ↓ 无限循环

解决方法：

- Logger 实现时避免使用会触发日志的库

- 或使用线程局部变量检测递归

------

## 九、总结

### 核心思想

"不要调用我们，我们会调用你"（Hollywood Principle）

### 本质

日志回调是一种控制反转（IoC）和依赖注入（DI）的具体应用：

- 库不主动依赖具体实现

- 上层注入所需的依赖（日志能力）

- 通过抽象接口（函数指针/std::function）解耦

### 适用场景

-  可复用的底层库

-  需要支持多种日志后端

-  性能敏感的场景

-  需要灵活配置的系统

### 不适用场景

-  简单的单体应用（过度设计）

-  只有一种日志实现且不会改变

-  团队不熟悉回调模式